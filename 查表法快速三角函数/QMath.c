#include "QMath.h"
#include "stm32f10x.h"                  // Device header
#include <math.h>

/*
	注意：所 有 函 数 输 出 都 是 角 度
*/
/********************************************************************
 *简	介：sin字典Q15
 *参	数：无
 *返回值：无
 *说	明：步进角0.5，范围【0-90】
 *********************************************************************/
const int16_t sin_lut[181]=
{   0,			286,		572,		858,		1144,		1429,		1715,		2000,		2286,
    2571,		2856,		3141,		3425,		3709,		3993,		4277,		4560,		4843,		5126,
    5408,		5690,		5971,		6252,		6533,		6813,		7092,		7371,		7649,		7927,
    8204,		8481,		8757,		9032,		9306,		9580,		9853,		10126,	10397,	10668,
    10938,	11207,	11475,	11743,	12009,	12275,	12539,	12803,	13066,	13328,
    13588,	13848,	14107,	14364,	14621,	14876,	15130,	15383,	15635,	15886,
    16135,	16384,	16631,	16876,	17121,	17364,	17606,	17846,	18085,	18323,
    18559,	18794,	19028,	19260,	19491,	19720,	19947,	20173,	20398,	20621,
    20842,	21062,	21280,	21497,	21712,	21925,	22137,	22347,	22555,	22762,
    22967,	23170,	23371,	23571,	23768,	23964,	24158,	24351,	24541,	24730,
    24916,	25101,	25284,	25465,	25644,	25821,	25996,	26169,	26340,	26509,
    26676,	26841,	27004,	27165,	27324,	27481,	27635,	27788,	27938,	28087,
    28233,	28377,	28519,	28659,	28796,	28932,	29065,	29196,	29324,	29451,
    29575,	29697,	29817,	29934,	30049,	30162,	30273,	30381,	30487,	30591,
    30692,	30791,	30888,	30982,	31074,	31163,	31250,	31335,	31418,	31498,
    31575,	31650,	31723,	31794,	31862,	31927,	31990,	32051,	32109,	32165,
    32218,	32269,	32318,	32364,	32407,	32448,	32487,	32523,	32556,	32587,
    32616,	32642,	32666,	32687,	32706,	32722,	32736,	32747,	32756,	32762,
    32766,	32767,
};

/********************************************************************
 *简	介：快速sin函数
 *参	数：角度（°）
 *返回值：对应的sin值
 *说	明：无
 *********************************************************************/
float sin_fast(float angle)
{
    int8_t sign = 1;				//符号
    float map_angle = 0.0f; //【0，360】到【0，90】映射后的角度
    /*限制[0,360]*/
    angle = fmodf(angle,360.0f);
    if(angle < 0.0f)
        angle += 360.0f;
    /*判断象限,结合图像，看差值，变换到【0，90】*/
    if(angle > 270.0f)				//第四象限
    {
        sign = -1;
        map_angle = 360.0f - angle;
    }
    else if(angle >180.0f)		//第三象限
    {
        sign = -1;
        map_angle = angle - 180.0f;
    }
    else if(angle > 90.0f)		//第二象限
    {
        sign = 1;
        map_angle = 180.0f - angle;
    }
    else											//第一象限
    {
        sign = 1;
        map_angle = angle;
    }
    /*线性插值*/
    float index_float = map_angle * 2.0f;			//乘2是因为是0.5度的步进，计算索引，假设30.3，计算得到60.6
    uint16_t index_low = (uint16_t)(index_float);		//舍弃小数，取得索引60
    //解释下面为什么不用除2
    //从数字的变换来说误差是0.3，但是从索引来说误差是0.6，索引与对应数值也可以看作是一一对应，
    //就是说索引增加1，对于误差来说就是增加0.5，而这里的0.6是说两个索引之间相差0.6，用索引进行线性变换
    float frac = (index_float - index_low);		//取得小数部分，用于插值计算
    /*边界检查*/
    //当角度为90°时index_low会是180，下面的加一就会变成181，数组越界
    if (index_low >= 180) {
        return sign * sin_lut[180] * INV_32767;
    }
    int16_t y0 = sin_lut[index_low];					//取得第60个数
    int16_t y1 = sin_lut[index_low + 1];			//取得第61个
    /*线性插值*/
    // 优化：使用定点数进行插值计算
    // 将frac转换为Q15格式（0-32767代表0.0-1.0）
    int16_t frac_q15 = (int16_t)(frac * 32767.0f);
    // 插值公式: y0 + ((y1 - y0) * frac_q15) >> 15
    int32_t diff = (int32_t)(y1 - y0);
    int32_t interpolated_value = (y0 + ((diff * frac_q15) >> 15));		//Q15*Q15=Q30,右移15相当于 /32767变回Q15
    return sign * (float)interpolated_value * INV_32767;							//转换为角度
}

/********************************************************************
 *简	介：快速cos函数
 *参	数：角度（°）
 *返回值：对应的cos值
 *说	明：无
 *********************************************************************/
float cos_fast(float angle)
{
    return sin_fast(angle + 90.0f);		//cos = sin(x + 90)
}

/********************************************************************
 *简	介：快速tan函数
 *参	数：角度（°）
 *返回值：对应的tan值
 *说	明：无
 *********************************************************************/
float tan_fast(float angle)
{
    return sin_fast(angle) / cos_fast(angle);		//tan = sin/cos
}

/********************************************************************
 *简	介：快速arcsin函数
 *参	数：对应sin值
 *返回值：对应sin角度
 *说	明：无
 *********************************************************************/
float asin_fast(float asin)
{
    /*检查参数合法*/
    if(asin >= 	1.0f)		return 	90.0f;
    if(asin <= -1.0f)		return -90.0f;
    /*处理符号问题*/
    int8_t sign = 1;
    if(asin < 0.0f)
    {
        sign = -1;
        asin =-asin;
    }
    /*转为Q15格式*/
    int16_t asin_q15 = (int16_t)round(asin * 32767.0f);
    /*二分查找*/
    uint8_t low  = 0;
    uint8_t high = 180;
    uint8_t mid  = 90;
    while(low <= high)
    {
        mid = (high + low) / 2;
        if(asin_q15 > sin_lut[mid])						//处于（mid，high）
            low = mid + 1;
        else if(asin_q15 < sin_lut[mid])			//处于（low，mid）
            high = mid - 1;
        else																	//找到精确值
            return	(float)mid * 0.5f;					//0.5步进，需要除2
    }
    /*线性插值*/
    //二分查找结束后，high是数值低的那一个，low是数值高的
    /*
    		sin_lut[high]  asin_q15    sin_lut[low]
             │          │          │
    	角度: high  			结果角度   	low
    */
//	float q15_err = asin_q15 - sin_lut[high];		//目标值 - 较低的值，得到Q15格式的目标角度比较低角度多多少数值
//	float err = sin_lut[low] - sin_lut[high];		//较高的值 - 较低的值
    float frac = (float)(asin_q15 - sin_lut[high]) / (float)(sin_lut[low] - sin_lut[high]);
    //通过（Q15数值差/目标值两边索引）得到一个比例关系
    return sign * (high + (frac * (low - high))) * 0.5f;
}

/********************************************************************
 *简	介：快速arccos函数
 *参	数：对应cos值
 *返回值：对应cos角度
 *说	明：无
 *********************************************************************/
float acos_fast(float acos)
{
    return PI_INV2 - asin_fast(acos);		//arccos = PI/2 - arcsin
}

/********************************************************************
 *简	介：快速arctan函数
 *参	数：对应tan值
 *返回值：对应tan角度
 *说	明：无
 *********************************************************************/
float atan_fast(float atan)
{
    return asin_fast(atan / sqrt(1.0f+atan * atan));
}

/********************************************************************
 *简	介：快速arctan2函数
 *参	数：对应tan值
 *返回值：对应tan角度
 *说	明：无
 *********************************************************************/
float atan2_fast(float y,float x)
{
    if (x > 0.0f)
    {
        return atan_fast(y / x);
    } else if (x < 0.0f)
    {
        if (y >= 0.0f)
        {
            return PI + atan_fast(y / x);
        } else
        {
            return -PI + atan_fast(y / x);
        }
    } else
    {   // x == 0
        if (y > 0.0f) return PI_INV2;
        else if (y < 0.0f) return -PI_INV2;
        else return 0.0f; // 未定义，通常返回0
    }
}
